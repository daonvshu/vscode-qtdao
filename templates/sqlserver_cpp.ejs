/********************************************************************************
** This file is auto generated by vscode-qtdao.
** Don't modify this file!
********************************************************************************/
#pragma once

#include "<%- className.toLowerCase() %>.h"

int <%- className %>::Info::fieldSize() {
    return <%- fieldWithoutTransient.length %>;
}

QString <%- className %>::Info::getTableName() {
    return QLatin1String("<%- tableName %>");
}

QString <%- className %>::Info::getSourceName() {
    return getTableName();
}

QStringList <%- className %>::Info::getFields() {
    return {
        <%_ fieldWithoutTransient.forEach(field => { -%>
        QLatin1String("<%- nameInDatabase(field.name) %>"),
        <%_ }) -%>
    };
}

QStringList <%- className %>::Info::getFieldsWithoutAutoIncrement() {
    return {
        <%_ fieldWithoutTransient.forEach(field => { -%>
            <%_ if (!field.autoIncrement) { -%>
        QLatin1String("<%- nameInDatabase(field.name) %>"),
            <%_ } -%>
        <%_ }) -%>
    };
}

QStringList <%- className %>::Info::getFieldsType() {
    return {
        <%_ databaseMemberDeclare.forEach(str => { -%>
        QStringLiteral("<%- str %>"),
        <%_ }) -%>
    };
}

QStringList <%- className %>::Info::getPrimaryKeys() {
    return {
        <%_ fieldWithoutTransient.forEach(field => { -%>
            <%_ if (field.constraint === 'primary key') { -%>
        QLatin1String("<%- nameInDatabase(field.name) %>"),
            <%_ } -%>
        <%_ }) -%>
    };
}

QList<QStringList> <%- className %>::Info::getClusteredIndexFields() {
    return {
        <%_ indexes.forEach(index => { -%>
            <%_ if (index.indexType === 'clustered') { -%>
        { <%- index.fields.map(field => nameInDatabase(field)).escapeMerge(', ') %> },
            <%_ } -%>
        <%_ }) -%>
    };
}

QList<QStringList> <%- className %>::Info::getUniqueClusteredIndexFields() {
    return {
        <%_ indexes.forEach(index => { -%>
            <%_ if (index.indexType === 'unique clustered') { -%>
        { <%- index.fields.map(field => nameInDatabase(field)).escapeMerge(', ') %> },
            <%_ } -%>
        <%_ }) -%>
    };
}

QList<QStringList> <%- className %>::Info::getNonClusteredIndexFields() {
    return {
        <%_ indexes.forEach(index => { -%>
            <%_ if (index.indexType === 'nonclustered') { -%>
        { <%- index.fields.map(field => nameInDatabase(field)).escapeMerge(', ') %> },
            <%_ } -%>
        <%_ }) -%>
    };
}

QList<QStringList> <%- className %>::Info::getUniqueNonClusteredIndexFields() {
    return {
        <%_ indexes.forEach(index => { -%>
            <%_ if (index.indexType === 'unique nonclustered') { -%>
        { <%- index.fields.map(field => nameInDatabase(field)).escapeMerge(', ') %> },
            <%_ } -%>
        <%_ }) -%>
    };
}

QString <%- className %>::Info::getIndexOption(const QString& name) {
    <%_ indexes.filter(index => index.indexOptions.isNotEmpty()).forEach(index => { -%>
    if(name == QLatin1String("index<%- index.fields.map(field => '_' + field.split(' ')[0]).merge() %>")) {
        return QLatin1String("<%- index.indexOptions %>");
    }
    <%_ }) -%>
    return {};
}

bool <%- className %>::Info::isAutoIncrement(const QString& name) {
    return 
    <%_ if (autoincFields.length !== 0) { -%>
        <%_ autoincFields.forEach((field, index) => { -%>
        name == QLatin1String("<%- nameInDatabase(field.name) %>")<% if (index !== autoincFields.length - 1) { %> ||<% } %>
        <%_ }) -%>
        ;
    <%_ } else { -%>
        false;
    <%_ } -%>
}

QList<ForeignKey> <%- className %>::Info::getForeignKeys() {
    return {
        <%_ foreignKeys.filter(key => !key.refvirtual).forEach(key => { -%>
        ForeignKey(QLatin1String("<%- databaseTbNameFormat(key.referTable) %>"), <%- foreignKeyActionToEnum(key.onUpdateAction) %>, <%- foreignKeyActionToEnum(key.onDeleteAction) %>, <%- key.deferrable %>).field(<%- key.referFields.map(field => nameInDatabase(field)).escapeMerge(", ") %>),
        <%_ }) -%>
    };
}
    
QVariantList <%- className %>::Tool::getValueWithoutAutoIncrement(const <%- className %>& entity) {
    return QVariantList()
        <%_ fieldWithoutTransient.forEach(field => { -%>
            <%_ if (!field.autoIncrement) { -%>
        << <%- serializableName(field) %>
            <%_ } -%>
        <%_ }) -%>
    ;
}

QVariant <%- className %>::Tool::getValueByName(const <%- className %>& entity, const QString& target) {
    <%_ fieldWithoutTransient.forEach(field => { -%>
    if (target == QLatin1String("<%- field.name.snakeCase() %>")) {
        return <%- serializableName(field) %>;
    }
    <%_ }) -%>
    return entity.__extra.value(target);
}

void <%- className %>::Tool::bindAutoIncrementId(<%- className %>& entity, const QVariant& id) {
    <%_ if (autoincFields.length !== 0) { -%>
    entity.<%- autoincFields[0].name %> = id.value<<%- autoincFields[0].cppType %>>();
    <%_ } -%>
}

void <%- className %>::Tool::bindValue(<%- className %>& entity, const QString& target, QVariant value) {
    <%_ fieldWithoutTransient.forEach((field, index) => { -%>
    <%- index === 0 ? "" : "else " %>if (target == QLatin1String("<%- field.name.snakeCase() %>")) {
        entity.<%- field.name %> = <%- checkSerialzableValue(field) %>;
    }
    <%_ }) -%>
    else {
        entity.__putExtra(target, value);
    }
}

<%- className %> <%- className %>::Tool::fromJson(const QJsonObject& object) {
    <%- className %> entity;
    <%_ fromJsonDeclares.forEach(str => { -%>
    <%- str %>
    <%_ }) -%>
    return entity;
}

QJsonObject <%- className %>::Tool::toJson(const <%- className %>& entity, const QStringList& excludeKeys) {
    QJsonObject object;
    <%_ toJsonDeclares.forEach(str => { -%>
    <%- str %>
    <%_ }) -%>

    for (const auto& key : excludeKeys) {
        object.remove(key);
    }
    return object;
}
    
bool <%- className %>::operator==(const <%- className %>& other) const {
    return 
    <%_ let unAutoIncFields = fieldWithoutTransient.filter(field => !field.autoIncrement); -%>
    <%_ unAutoIncFields.forEach((field, index) => { -%>
        <%- field.name %> == other.<%- field.name %><%- index === unAutoIncFields.length - 1 ? "" : " &&" %>
    <%_ }) -%>
    ;
}

bool <%- className %>::operator!=(const <%- className %>& other) const {
    return !(*this == other);
}

<%_ if (foreignKeyLinks.length !== 0 || autoincFields.length === 1 || foreignKeys.length !== 0) { -%>
<%- '\n' -%>
#include <dao.h>
<%_ } -%>
<%_ if (foreignKeyLinks.length !== 0) { -%>
    <%_ foreignKeyLinks.forEach(foreignkey => { %>
    <%_ let nameByReferFields = foreignkey.referFields.filter((field, index) => index % 2 === 1).map(field => field.pascalCase()).merge(); -%>
    <%_ let filterCondition = foreignkey.referFields.map((field, index) => index % 2 === 0 ? `field.${field} == ${foreignkey.referFields[index + 1]}` : '').filter(Boolean).join(', ') -%>
<%- foreignkey.table %>List <%- className %>::get<%- foreignkey.table %>By<%- nameByReferFields %>() const {
    <%- foreignkey.table %>::Fields field;
    return dao::_select<<%- foreignkey.table %>>().filter(<%- filterCondition %>).build().list();
}

<%- foreignkey.table %> <%- className %>::get<%- foreignkey.table %>UniqueBy<%- nameByReferFields %>() const {
    <%- foreignkey.table %>::Fields field;
    return dao::_select<<%- foreignkey.table %>>().filter(<%- filterCondition %>).build().unique();
}

void <%- className %>::insert<%- foreignkey.table %>With<%- nameByReferFields %>(QList<<%- foreignkey.table %>>& entities) const {
    for (auto& entity : entities) {
        <%_ foreignkey.referFields.forEach((field, index) => { -%>
            <%_ if (index % 2 === 0) { -%>
        entity.<%- field %> = <%- foreignkey.referFields[index + 1] %>;
            <%_ } -%>
        <%_ }) -%>
    }
    dao::_insert<<%- foreignkey.table %>>().build().insert(entities);
}

void <%- className %>::insert<%- foreignkey.table %>With<%- nameByReferFields %>(<%- foreignkey.table %>& entity) const {
    <%_ foreignkey.referFields.forEach((field, index) => { -%>
        <%_ if (index % 2 === 0) { -%>
    entity.<%- field %> = <%- foreignkey.referFields[index + 1] %>;
        <%_ } -%>
    <%_ }) -%>
    dao::_insert<<%- foreignkey.table %>>().build().insert(entity);
}

void <%- className %>::clear<%- foreignkey.table %>By<%- nameByReferFields %>() const {
    <%- foreignkey.table %>::Fields field;
    return dao::_delete<<%- foreignkey.table %>>().filter(<%- filterCondition %>).build().deleteBy();
}
    <%_ }) -%>
<%_ } -%>
<%_ if (foreignKeys.length !== 0) { -%>
    <%_ foreignKeys.forEach(key => { %>
        <%_ let referFields = key.referFields.filter((field, index) => index % 2 === 0); -%>
        <%_ let nameByReferFields = referFields.map(field => field.pascalCase()).merge(); -%>
        <%_ let filterCondition = referFields.map(field => `field.${field} == ${field}`).join(', ') -%>
<%- className %> <%- className %>::loadBy<%- nameByReferFields %>(<%- referFields.map(field => `const ${getCppTypeByFieldName(field)}& ${field}`).join(', ') %>) {
    Fields field;
    return dao::_select<<%- className %>>().filter(<%- filterCondition %>).build().unique();
}
    <%_ }) -%>
<%_ } -%>
<% if (autoincFields.length === 1) { -%>
<%- '\n' -%>
void <%- className %>::insert() {
    dao::_insert<<%- className %>>().build().insert(*this);
}

void <%- className %>::update() const {
    dao::_update<<%- className %>>().build().update(*this);
}

void <%- className %>::select() {
    Fields field;
    *this = dao::_select<<%- className %>>().filter(field.<%- autoincFields[0].name %> == <%- autoincFields[0].name %>).build().unique();
}

<%- className %> <%- className %>::select(const <%- autoincFields[0].cppType %>& <%- autoincFields[0].name %>) {
    Fields field;
    return dao::_select<<%- className %>>().filter(field.<%- autoincFields[0].name %> == <%- autoincFields[0].name %>).build().unique();
}

void <%- className %>::remove() const {
    dao::_delete<<%- className %>>().build().deleteBy(*this);
}

void <%- className %>::remove(const <%- autoincFields[0].cppType %>& <%- autoincFields[0].name %>) {
    Fields field;
    dao::_delete<<%- className %>>().filter(field.<%- autoincFields[0].name %> == <%- autoincFields[0].name %>).build().deleteBy();
}
<% } -%>